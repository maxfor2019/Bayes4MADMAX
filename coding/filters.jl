println("Hello there!")

# Come up with realistic priors on axion mass and abundancy from theory parameters
using BAT
using Random, LinearAlgebra, Statistics, Distributions, StatsBase
include("custom_distributions.jl")
using Plots, LaTeXStrings
using ValueShapes
using IntervalSets
using FileIO, JLD2 # for saving the samples

include("physics.jl")
include("read_data.jl")
include("plotting.jl")
include("forward_models.jl")

using SavitzkyGolay
using StatsPlots
using HDF5

################ PART 1 - Definitions #####################################################

function add_artificial_background!(data)
    data[:,2] .+=  (deepcopy(data[:,1]).-7e6).^3 .* 1e-42 .* (1. +randn()) .- (deepcopy(data[:,1]).-7e6).^2 .* 1e-35 .* (1. +randn()) .- (deepcopy(data[:,1]).-7e6) .* 1e-29 .* (1. +randn()) .+ 1e-20  .+ 2e-24 .* (1. +randn()) .* sin.(deepcopy(data[:,1])./5e4) .+ 1e-23 .* (1. +randn()) .* sin.(deepcopy(data[:,1])./20e4)
    return data
end

function dummy_data(;scale=9.4e-24)
    data = gaussian_noise(4e6,9e6,2.034e3,scale=scale)
end

function add_axion!(data, signal)
    rel_freqs = data[:,1]
    vals = data[:,2]

    # will have to cut half of the SG length

    options=(
        # reference frequency
        f_ref = 11.0e9,
    )

    Δfreq = mean([rel_freqs[i] - rel_freqs[i-1] for i in 2:length(rel_freqs)])
    freqs = rel_freqs .+ options.f_ref

    ex = Experiment(Be=10.0, A=1.0, β=5e4, t_int=100.0, Δω=Δfreq) # careful not to accidentally ignore a few of the relevant parameters!

    my_axion = let f = freqs, ex = ex
        function ax(parameters)
            sig = axion_forward_model(parameters, ex, f)
            if maximum(sig) > 0.0
                nothing
            else
                error("The specified axion model is not within the frequency range of your data. Fiddle around with signal.ma or options.f_ref!")
            end
            return sig
        end

    end
    ax = my_axion(signal)
    data[:,2] += ax
    return data
end

function my_normalize(data, scale=mean(data[:,2]))
    data[:,2] ./= scale
    return data, scale
end

signal = Theory(
    ma=45.517, 
    rhoa=0.3,
    EoverN=0.1,
    σ_v=218.0,
    vlab=242.1
)

################ PART 2 - write data #####################################################
# do not execute this part
# runtime ~ 1h

# Writes mock data generated by the functions above into a set of files.
path = "/remote/ceph/user/d/diehl/MADMAXsamples/FilterTest/MockDatasets/"
nr_of_samples = 5000
s_bin = 968 # signal bin, i.e. the most interesting bin for analysis
bin_list_ideal = ones(nr_of_samples,2)
@time for i in range(1,length(bin_list_ideal[:,1]))
    println(i)
    scale = 9.4e-24
    data = dummy_data(scale=scale)
    rel_freqs = data[:,1]
    Δfreq = mean([rel_freqs[i] - rel_freqs[i-1] for i in 2:length(rel_freqs)])
    ex = "Experiment(Be=10.0, A=1.0, β=5e4, t_int=100.0, Δω="*string(Δfreq)*")"
    sig = "Theory(ma=45.517, rhoa=0.3,EoverN=0.1,σ_v=218.0,vlab=242.1)"
    options="(f_ref = 11.0e9,)"
    h5write(path*"test5000-"*string(i)*".h5", "scale", scale)
    h5write(path*"test5000-"*string(i)*".h5", "experiment", ex)
    h5write(path*"test5000-"*string(i)*".h5", "signal", sig)
    h5write(path*"test5000-"*string(i)*".h5", "options", options)
    h5write(path*"test5000-"*string(i)*".h5", "noise", data)
    add_axion!(data, signal)
    h5write(path*"test5000-"*string(i)*".h5", "noise+ax", data)
    add_artificial_background!(data)
    h5write(path*"test5000-"*string(i)*".h5", "noise+ax+bg", data)
    data, scale = my_normalize(data, 1e-20)
    i += 1
end

################ PART 3 - look at data #####################################################
# read out basic properties from data written in Part 2.

# example data plot
data = h5read(path*"test5000-"*string(134)*".h5", "noise+ax+bg")
sig = h5read(path*"test5000-"*string(134)*".h5", "signal")
println(sig) # unfortunately this is a string and not a usable object. But at least I saved the metadata...
plot(data[:,1], data[:,2]/1e-20)

################ PART 4 - ideal analysis #####################################################
# runtime ~ seconds

# analysis for ideal case wo/ background
bin_list_ideal = []
@time for i in range(1,5000)
    append!(bin_list_ideal, h5read(path*"test5000-"*string(i)*".h5", "noise+ax")[s_bin,2])
    i += 1
end
bin_list_ideal *= 1e20
gauss_ideal = fit(Normal, bin_list_ideal) # Fit a gaussian on the histogram and use this afterwards to calculate η.
histogram(bin_list_ideal, alpha=0.5, label="ideal")
plot!(gauss_ideal)

################ PART 5 - SG analysis #####################################################
# runtime ~ seconds

# This is the equivalent what I did for SG filter. You would need to adapt this to MGVI
bin_list_sg = []
bin_list_noise = []
s_bin = 968
@time for i in range(1,5000)
    data = h5read(path*"test5000-"*string(i)*".h5", "noise+ax+bg")
    data, scale = my_normalize(data, 1e-20)
    w = 201
    d=6
    sg = savitzky_golay(data[:,2], w, d)
    data = data[w:end-w,:]
    myfit = sg.y[w:end-w]
    data[:,2] = data[:,2] - myfit
    append!(bin_list_sg, data[s_bin-w+1,2])
    append!(bin_list_noise, data[s_bin-w+50,2])
end
bin_list_sg *= 1. # convert Vector{Any} to Vector{Float}
bin_list_noise *= 1.
gauss_sg = fit(Normal, bin_list_sg)
gauss_noise = fit(Normal, bin_list_noise)
histogram!(bin_list_sg, alpha=0.5, label="SG filter")
histogram!(bin_list_noise, alpha=0.5, label="no signal")
plot!(gauss_sg)

# These functions are what we care for in the end. The higher the η the better!
η(normal1, normal2) = normal1.μ / normal2.μ * normal2.σ / normal1.σ
ξ(normal1, normal2) = normal1.σ / normal2.σ
ξ(gauss_sg, gauss_ideal)
η(gauss_sg, gauss_ideal)

